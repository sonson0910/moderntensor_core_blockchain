// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

/**
 * @title ModernTensor
 * @dev Smart contract for decentralized AI training on Core blockchain
 * Features Bitcoin staking integration and dual staking economics
 */
contract ModernTensor is ReentrancyGuard, Ownable {
    using SafeMath for uint256;

    // Core token for staking
    IERC20 public immutable coreToken;

    // Staking tier constants
    uint256 public constant BASE_TIER = 0; // 1x multiplier
    uint256 public constant BOOST_TIER = 1; // 1.25x multiplier
    uint256 public constant SUPER_TIER = 2; // 1.5x multiplier
    uint256 public constant SATOSHI_TIER = 3; // 2x multiplier

    // Staking tier thresholds (in CORE tokens)
    uint256 public constant BOOST_THRESHOLD = 1000e18; // 1,000 CORE
    uint256 public constant SUPER_THRESHOLD = 10000e18; // 10,000 CORE
    uint256 public constant SATOSHI_THRESHOLD = 50000e18; // 50,000 CORE

    // Staking multipliers (basis points, 10000 = 100%)
    uint256 public constant BASE_MULTIPLIER = 10000; // 100%
    uint256 public constant BOOST_MULTIPLIER = 12500; // 125%
    uint256 public constant SUPER_MULTIPLIER = 15000; // 150%
    uint256 public constant SATOSHI_MULTIPLIER = 20000; // 200%

    // Minimum stake amounts
    uint256 public constant MIN_MINER_STAKE = 100e18; // 100 CORE
    uint256 public constant MIN_VALIDATOR_STAKE = 1000e18; // 1,000 CORE

    // Performance and trust score scales
    uint256 public constant MAX_PERFORMANCE_SCORE = 10000;
    uint256 public constant MAX_TRUST_SCORE = 10000;

    // Enums
    enum NodeStatus {
        INACTIVE,
        ACTIVE,
        SUSPENDED,
        BANNED
    }

    // Structs
    struct MinerInfo {
        bytes32 uid;
        uint64 subnetUid;
        uint256 stake;
        uint256 bitcoinStake;
        uint256 lastPerformance;
        uint256 trustScore;
        uint256 accumulatedRewards;
        uint256 lastUpdateTimestamp;
        uint256 registrationTimestamp;
        NodeStatus status;
        bytes32 performanceHistoryHash;
        string apiEndpoint;
        address owner;
    }

    struct ValidatorInfo {
        bytes32 uid;
        uint64 subnetUid;
        uint256 stake;
        uint256 bitcoinStake;
        uint256 validationCount;
        uint256 accuracyScore;
        uint256 accumulatedRewards;
        uint256 lastUpdateTimestamp;
        uint256 registrationTimestamp;
        NodeStatus status;
        string apiEndpoint;
        address owner;
    }

    struct SubnetInfo {
        uint64 uid;
        string name;
        uint256 totalStake;
        uint256 minerCount;
        uint256 validatorCount;
        uint256 rewardPool;
        uint256 creationTimestamp;
        address owner;
        bool isActive;
    }

    struct BitcoinStakeInfo {
        bytes32 txHash;
        uint256 amount;
        uint256 lockTime;
        uint256 unlockTime;
        bool isActive;
        uint256 timestamp;
    }

    // State variables
    mapping(address => MinerInfo) public miners;
    mapping(address => ValidatorInfo) public validators;
    mapping(uint64 => SubnetInfo) public subnets;
    mapping(address => BitcoinStakeInfo[]) public bitcoinStakes;
    mapping(address => uint256) public totalBitcoinStake;

    address[] public allMiners;
    address[] public allValidators;
    uint64[] public allSubnets;

    uint64 public nextSubnetId = 1;
    uint256 public totalStaked;
    uint256 public totalBitcoinStaked;

    // Events
    event MinerRegistered(
        address indexed miner,
        bytes32 indexed uid,
        uint64 indexed subnetUid,
        uint256 stake,
        string apiEndpoint
    );

    event ValidatorRegistered(
        address indexed validator,
        bytes32 indexed uid,
        uint64 indexed subnetUid,
        uint256 stake,
        string apiEndpoint
    );

    event BitcoinStaked(
        address indexed user,
        bytes32 indexed txHash,
        uint256 amount,
        uint256 lockTime
    );

    event MinerScoresUpdated(
        address indexed miner,
        uint256 performance,
        uint256 trustScore
    );

    event RewardsDistributed(
        address indexed recipient,
        uint256 amount,
        uint256 stakingTier
    );

    event SubnetCreated(
        uint64 indexed subnetId,
        string name,
        address indexed owner
    );

    // Constructor
    constructor(address _coreToken) {
        coreToken = IERC20(_coreToken);
    }

    // Miner functions
    function registerMiner(
        bytes32 uid,
        uint64 subnetUid,
        uint256 stakeAmount,
        string memory apiEndpoint
    ) external payable nonReentrant {
        require(
            miners[msg.sender].owner == address(0),
            "Miner already registered"
        );
        require(stakeAmount >= MIN_MINER_STAKE, "Insufficient stake amount");
        require(subnets[subnetUid].isActive, "Subnet not active");

        // Transfer stake
        require(
            coreToken.transferFrom(msg.sender, address(this), stakeAmount),
            "Stake transfer failed"
        );

        // Register miner
        miners[msg.sender] = MinerInfo({
            uid: uid,
            subnetUid: subnetUid,
            stake: stakeAmount,
            bitcoinStake: 0,
            lastPerformance: 0,
            trustScore: 5000, // Start with 50% trust score
            accumulatedRewards: 0,
            lastUpdateTimestamp: block.timestamp,
            registrationTimestamp: block.timestamp,
            status: NodeStatus.ACTIVE,
            performanceHistoryHash: bytes32(0),
            apiEndpoint: apiEndpoint,
            owner: msg.sender
        });

        allMiners.push(msg.sender);
        totalStaked = totalStaked.add(stakeAmount);
        subnets[subnetUid].minerCount++;
        subnets[subnetUid].totalStake = subnets[subnetUid].totalStake.add(
            stakeAmount
        );

        emit MinerRegistered(
            msg.sender,
            uid,
            subnetUid,
            stakeAmount,
            apiEndpoint
        );
    }

    function registerValidator(
        bytes32 uid,
        uint64 subnetUid,
        uint256 stakeAmount,
        string memory apiEndpoint
    ) external nonReentrant {
        require(
            validators[msg.sender].owner == address(0),
            "Validator already registered"
        );
        require(
            stakeAmount >= MIN_VALIDATOR_STAKE,
            "Insufficient stake amount"
        );
        require(subnets[subnetUid].isActive, "Subnet not active");

        // Transfer stake
        require(
            coreToken.transferFrom(msg.sender, address(this), stakeAmount),
            "Stake transfer failed"
        );

        // Register validator
        validators[msg.sender] = ValidatorInfo({
            uid: uid,
            subnetUid: subnetUid,
            stake: stakeAmount,
            bitcoinStake: 0,
            validationCount: 0,
            accuracyScore: 5000, // Start with 50% accuracy score
            accumulatedRewards: 0,
            lastUpdateTimestamp: block.timestamp,
            registrationTimestamp: block.timestamp,
            status: NodeStatus.ACTIVE,
            apiEndpoint: apiEndpoint,
            owner: msg.sender
        });

        allValidators.push(msg.sender);
        totalStaked = totalStaked.add(stakeAmount);
        subnets[subnetUid].validatorCount++;
        subnets[subnetUid].totalStake = subnets[subnetUid].totalStake.add(
            stakeAmount
        );

        emit ValidatorRegistered(
            msg.sender,
            uid,
            subnetUid,
            stakeAmount,
            apiEndpoint
        );
    }

    // Bitcoin staking functions
    function stakeBitcoin(
        bytes32 txHash,
        uint256 amount,
        uint256 lockTime
    ) external {
        require(
            miners[msg.sender].owner == msg.sender ||
                validators[msg.sender].owner == msg.sender,
            "Must be registered miner or validator"
        );
        require(amount > 0, "Amount must be greater than 0");
        require(lockTime > block.timestamp, "Lock time must be in the future");

        // Add Bitcoin stake info
        bitcoinStakes[msg.sender].push(
            BitcoinStakeInfo({
                txHash: txHash,
                amount: amount,
                lockTime: lockTime,
                unlockTime: 0,
                isActive: true,
                timestamp: block.timestamp
            })
        );

        totalBitcoinStake[msg.sender] = totalBitcoinStake[msg.sender].add(
            amount
        );
        totalBitcoinStaked = totalBitcoinStaked.add(amount);

        // Update miner or validator Bitcoin stake
        if (miners[msg.sender].owner == msg.sender) {
            miners[msg.sender].bitcoinStake = miners[msg.sender]
                .bitcoinStake
                .add(amount);
        } else {
            validators[msg.sender].bitcoinStake = validators[msg.sender]
                .bitcoinStake
                .add(amount);
        }

        emit BitcoinStaked(msg.sender, txHash, amount, lockTime);
    }

    // Score update functions
    function updateMinerScores(
        address minerAddr,
        uint256 newPerformance,
        uint256 newTrustScore
    ) external onlyOwner {
        require(miners[minerAddr].owner != address(0), "Miner not found");
        require(
            newPerformance <= MAX_PERFORMANCE_SCORE,
            "Performance score too high"
        );
        require(newTrustScore <= MAX_TRUST_SCORE, "Trust score too high");

        miners[minerAddr].lastPerformance = newPerformance;
        miners[minerAddr].trustScore = newTrustScore;
        miners[minerAddr].lastUpdateTimestamp = block.timestamp;

        emit MinerScoresUpdated(minerAddr, newPerformance, newTrustScore);
    }

    function updateValidatorScores(
        address validatorAddr,
        uint256 newAccuracy,
        uint256 newValidationCount
    ) external onlyOwner {
        require(
            validators[validatorAddr].owner != address(0),
            "Validator not found"
        );
        require(
            newAccuracy <= MAX_PERFORMANCE_SCORE,
            "Accuracy score too high"
        );

        validators[validatorAddr].accuracyScore = newAccuracy;
        validators[validatorAddr].validationCount = newValidationCount;
        validators[validatorAddr].lastUpdateTimestamp = block.timestamp;
    }

    // Subnet management
    function createSubnet(string memory name) external returns (uint64) {
        uint64 subnetId = nextSubnetId++;

        subnets[subnetId] = SubnetInfo({
            uid: subnetId,
            name: name,
            totalStake: 0,
            minerCount: 0,
            validatorCount: 0,
            rewardPool: 0,
            creationTimestamp: block.timestamp,
            owner: msg.sender,
            isActive: true
        });

        allSubnets.push(subnetId);

        emit SubnetCreated(subnetId, name, msg.sender);
        return subnetId;
    }

    // Staking tier calculation
    function calculateStakingTier(
        address user
    ) external view returns (uint256) {
        uint256 totalStake = 0;

        // Add CORE stake
        if (miners[user].owner == user) {
            totalStake = totalStake.add(miners[user].stake);
        } else if (validators[user].owner == user) {
            totalStake = totalStake.add(validators[user].stake);
        }

        // Add Bitcoin stake (weighted)
        totalStake = totalStake.add(totalBitcoinStake[user]);

        // Determine tier
        if (totalStake >= SATOSHI_THRESHOLD) {
            return SATOSHI_TIER;
        } else if (totalStake >= SUPER_THRESHOLD) {
            return SUPER_TIER;
        } else if (totalStake >= BOOST_THRESHOLD) {
            return BOOST_TIER;
        } else {
            return BASE_TIER;
        }
    }

    function getStakingMultiplier(
        uint256 tier
    ) external pure returns (uint256) {
        if (tier == SATOSHI_TIER) {
            return SATOSHI_MULTIPLIER;
        } else if (tier == SUPER_TIER) {
            return SUPER_MULTIPLIER;
        } else if (tier == BOOST_TIER) {
            return BOOST_MULTIPLIER;
        } else {
            return BASE_MULTIPLIER;
        }
    }

    // View functions
    function getMinerInfo(
        address minerAddr
    ) external view returns (MinerInfo memory) {
        return miners[minerAddr];
    }

    function getValidatorInfo(
        address validatorAddr
    ) external view returns (ValidatorInfo memory) {
        return validators[validatorAddr];
    }

    function getSubnetInfo(
        uint64 subnetId
    ) external view returns (SubnetInfo memory) {
        return subnets[subnetId];
    }

    function getAllMiners() external view returns (address[] memory) {
        return allMiners;
    }

    function getAllValidators() external view returns (address[] memory) {
        return allValidators;
    }

    function getAllSubnets() external view returns (uint64[] memory) {
        return allSubnets;
    }

    function getBitcoinStakes(
        address user
    ) external view returns (BitcoinStakeInfo[] memory) {
        return bitcoinStakes[user];
    }

    // Reward distribution functions
    function distributeRewards(
        address[] memory recipients,
        uint256[] memory amounts,
        uint256[] memory stakingTiers
    ) external onlyOwner nonReentrant {
        require(recipients.length == amounts.length, "Array length mismatch");
        require(
            recipients.length == stakingTiers.length,
            "Array length mismatch"
        );

        uint256 totalRewards = 0;

        for (uint256 i = 0; i < recipients.length; i++) {
            address recipient = recipients[i];
            uint256 baseAmount = amounts[i];
            uint256 tier = stakingTiers[i];

            // Apply staking tier multiplier
            uint256 multiplier = getStakingMultiplier(tier);
            uint256 finalAmount = (baseAmount * multiplier) / BASE_MULTIPLIER;

            // Update accumulated rewards
            if (miners[recipient].owner == recipient) {
                miners[recipient].accumulatedRewards += finalAmount;
            } else if (validators[recipient].owner == recipient) {
                validators[recipient].accumulatedRewards += finalAmount;
            }

            totalRewards += finalAmount;

            emit RewardsDistributed(recipient, finalAmount, tier);
        }

        // Transfer total rewards from contract
        require(
            coreToken.balanceOf(address(this)) >= totalRewards,
            "Insufficient contract balance"
        );
    }

    function claimRewards() external nonReentrant {
        uint256 rewards = 0;

        if (miners[msg.sender].owner == msg.sender) {
            rewards = miners[msg.sender].accumulatedRewards;
            miners[msg.sender].accumulatedRewards = 0;
        } else if (validators[msg.sender].owner == msg.sender) {
            rewards = validators[msg.sender].accumulatedRewards;
            validators[msg.sender].accumulatedRewards = 0;
        }

        require(rewards > 0, "No rewards to claim");
        require(
            coreToken.transfer(msg.sender, rewards),
            "Reward transfer failed"
        );

        emit RewardsDistributed(
            msg.sender,
            rewards,
            calculateStakingTier(msg.sender)
        );
    }

    // Slashing functions
    function slashNode(
        address nodeAddr,
        uint256 slashAmount,
        string memory reason
    ) external onlyOwner {
        require(slashAmount > 0, "Slash amount must be greater than 0");

        bool isSlashed = false;

        if (miners[nodeAddr].owner == nodeAddr) {
            require(
                miners[nodeAddr].stake >= slashAmount,
                "Insufficient stake to slash"
            );
            miners[nodeAddr].stake = miners[nodeAddr].stake.sub(slashAmount);
            subnets[miners[nodeAddr].subnetUid].totalStake = subnets[
                miners[nodeAddr].subnetUid
            ].totalStake.sub(slashAmount);
            isSlashed = true;
        } else if (validators[nodeAddr].owner == nodeAddr) {
            require(
                validators[nodeAddr].stake >= slashAmount,
                "Insufficient stake to slash"
            );
            validators[nodeAddr].stake = validators[nodeAddr].stake.sub(
                slashAmount
            );
            subnets[validators[nodeAddr].subnetUid].totalStake = subnets[
                validators[nodeAddr].subnetUid
            ].totalStake.sub(slashAmount);
            isSlashed = true;
        }

        require(isSlashed, "Node not found or invalid");

        totalStaked = totalStaked.sub(slashAmount);

        emit NodeSlashed(nodeAddr, slashAmount, reason);
    }

    function banNode(
        address nodeAddr,
        string memory reason
    ) external onlyOwner {
        if (miners[nodeAddr].owner == nodeAddr) {
            miners[nodeAddr].status = NodeStatus.BANNED;
        } else if (validators[nodeAddr].owner == nodeAddr) {
            validators[nodeAddr].status = NodeStatus.BANNED;
        }

        emit NodeBanned(nodeAddr, reason);
    }

    // Bitcoin verification functions
    function verifyBitcoinTransaction(
        bytes32 txHash,
        bytes memory proof,
        uint256 blockHeight
    ) external view returns (bool) {
        // Simplified Bitcoin transaction verification
        // In production, this would use Bitcoin SPV proofs

        // Check if transaction hash is valid format
        require(txHash != bytes32(0), "Invalid transaction hash");

        // Check if proof is provided
        require(proof.length > 0, "Proof required");

        // Check if block height is reasonable
        require(blockHeight > 0, "Invalid block height");

        // For now, return true for valid format
        // TODO: Implement proper Bitcoin SPV verification
        return true;
    }

    function unlockBitcoinStake(address user, uint256 stakeIndex) external {
        require(stakeIndex < bitcoinStakes[user].length, "Invalid stake index");

        BitcoinStakeInfo storage stake = bitcoinStakes[user][stakeIndex];
        require(stake.isActive, "Stake already unlocked");
        require(block.timestamp >= stake.lockTime, "Lock time not reached");

        stake.isActive = false;
        stake.unlockTime = block.timestamp;

        // Update user's total Bitcoin stake
        totalBitcoinStake[user] = totalBitcoinStake[user].sub(stake.amount);
        totalBitcoinStaked = totalBitcoinStaked.sub(stake.amount);

        // Update node Bitcoin stake
        if (miners[user].owner == user) {
            miners[user].bitcoinStake = miners[user].bitcoinStake.sub(
                stake.amount
            );
        } else if (validators[user].owner == user) {
            validators[user].bitcoinStake = validators[user].bitcoinStake.sub(
                stake.amount
            );
        }

        emit BitcoinStakeUnlocked(user, stake.txHash, stake.amount);
    }

    // Network statistics functions
    function getNetworkStats()
        external
        view
        returns (
            uint256 totalMiners,
            uint256 totalValidators,
            uint256 totalStakedCore,
            uint256 totalStakedBitcoin,
            uint256 activeSubnets
        )
    {
        return (
            allMiners.length,
            allValidators.length,
            totalStaked,
            totalBitcoinStaked,
            allSubnets.length
        );
    }

    function getStakingTierName(
        uint256 tier
    ) external pure returns (string memory) {
        if (tier == SATOSHI_TIER) {
            return "Satoshi";
        } else if (tier == SUPER_TIER) {
            return "Super";
        } else if (tier == BOOST_TIER) {
            return "Boost";
        } else {
            return "Base";
        }
    }

    // Emergency functions
    function emergencyWithdraw() external onlyOwner {
        uint256 balance = coreToken.balanceOf(address(this));
        require(
            coreToken.transfer(owner(), balance),
            "Emergency withdraw failed"
        );
    }

    function pauseNode(address nodeAddr) external onlyOwner {
        if (miners[nodeAddr].owner == nodeAddr) {
            miners[nodeAddr].status = NodeStatus.SUSPENDED;
        } else if (validators[nodeAddr].owner == nodeAddr) {
            validators[nodeAddr].status = NodeStatus.SUSPENDED;
        }
    }

    function unpauseNode(address nodeAddr) external onlyOwner {
        if (miners[nodeAddr].owner == nodeAddr) {
            miners[nodeAddr].status = NodeStatus.ACTIVE;
        } else if (validators[nodeAddr].owner == nodeAddr) {
            validators[nodeAddr].status = NodeStatus.ACTIVE;
        }
    }

    // Additional events
    event NodeSlashed(address indexed node, uint256 amount, string reason);
    event NodeBanned(address indexed node, string reason);
    event BitcoinStakeUnlocked(
        address indexed user,
        bytes32 indexed txHash,
        uint256 amount
    );
}
